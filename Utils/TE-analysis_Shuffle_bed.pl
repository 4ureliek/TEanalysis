#!/usr/bin/perl
#######################################################
# Author  :  Aurelie Kapusta (https://github.com/4ureliek), with the help of Edward Chuong
# email   :  4urelie.k@gmail.com  
# Purpose :  Writen to test enrichment of TEs in a set of simple features (ChIP-seq for example) 
#######################################################
use strict;
use warnings;
use Carp;
use Getopt::Long;
use Bio::SeqIO;
use Math::CDF;

#-----------------------------------------------------------------------------
#------------------------------- DESCRIPTION ---------------------------------
#-----------------------------------------------------------------------------
#flush buffer
$| = 1;

my $version = "2.0";
my $scriptname = "TE-analysis_Shuffle_bed.pl";
my $changelog = "
#	- v1.0 = Mar 2016 
#            based on TE-analysis_Shuffle_v3+.pl, v3.3, 
#            but adapted to more general input files = bed file corresponding to any features to test.
#	- v2.0 = Mar 2016 
#            attempt of making this faster by removing any length info and allowing overlaps 
#            of shuffled features (since they are independent tests, it's OK)
#            Also added the possibility of several files to -e and -i
\n";

my $usage = "
Synopsis (v$version):

    perl $scriptname -f features.bed [-o <nt>] -s features_to_shuffle [-n <nb>] 
             -r <genome.range> [-b] -e <genome.gaps> [-d] [-i <include.range>] [-a] 
            [-l <if_nonTE>] [-t <filterTE>] [-c] [-w <bedtools_path>] [-v] [-h]

    /!\\ REQUIRES: Bedtools, at least v18 (but I advise updating up to the last version)
    /!\\ Previous outputs, if any, will be moved as *.previous [which means previous results are only saved once]

  DESCRIPTION:
    Features provided in -s will be overlapped with -i file (which must be simple intervals in bed format), 
       without (no_boot) or with (boot) shuffling (on same chromosome)
       One feature may overlap with several repeats and all are considered.
       Note that because TEs are often fragmented + there are inversions, the counts of TEs are likely inflated;
       this also means that when TEs are shuffled, there are more fragments than TEs. Some should be moved non independently, 
       or the input file should be corrected when possible to limit that issue [not implemented in this script for now]
       
    If you need to generate the <genome.gaps> file but you would also like to add more files to the -e option, 
       just do a first run with no bootstraps (in this example the genome.range is also being generated):
       perl ~/bin/$scriptname -f input.bed -s genome.out -r genome.fa -b -e genome.fa -d -n 0

    Two-tailed permutation test ans a binomial test are done on the counts of overlaps. 
       The results are in a .stats.txt file. Note that high bootstraps takes a lot of time. 
  
  MANDATORY ARGUMENTS:	
    -f,--feat     => (STRING) ChIPseq peaks, chromatin marks, etc, in bed format
                              /!\\ Script assumes no overlap between peaks
    -s,--shuffle  => (STRING) Features to shuffle = TE file
                              For now, can only be the repeat masker .out or the .bed file generated by the TE-analysis_pipeline script
                              No filtering on TEs in this script                           
    -r,--range    => (STRING) To know the maximum value in a given chromosome/scaffold. 
                              File should be: Name \\t length
                              Can be files from UCSC, files *.chrom.sizes
                              If you don't have such file, use -b (--build) and provide the genome fasta file for -r                               
    -e,--excl     => (STRING) This will be used as -excl for bedtools shuffle: \"coordinates in which features from -i should not be placed.\"
                              More than one file may be provided (comma separated), they will be concatenated 
                              (in a file = first-file-name.cat.bed).
                              By default, at least one file is required = assembly gaps, and it needs to be the first file
                              if not in bed format. Indeed, you may provide the UCSC gap file, with columns as:
                                  bin, chrom, chromStart, chromEnd, ix, n, size, type, bridge
                              it will be converted to a bed file. Additionally, you may provide the genome file in fasta format
                              and add the option -d (--dogaps), to generate a bed file corresponding to assembly gaps.
                              Other files may correspond to regions of low mappability, for example for hg19:
                              http://www.broadinstitute.org/~anshul/projects/encode/rawdata/blacklists/hg19-blacklist-README.pdf
                              Notes: -> when the bed file is generated by this script, any N stretch > 50nt will be considered as a gap 
                                        (this can be changed in the load_gap subroutine)         
                                     -> 3% of the shuffled feature may overlap with these regions 
                                        (this can be changed in the shuffle subroutine).
  OPTIONAL ARGUMENTS:
    -o,--overlap  => (INT)    Minimal length (in nt) of intersection in order to consider the TE included in the feature.
                              Default = 10 (to match the TEanalysis-pipeline.pl)
    -n,--nboot    => (STRING) number of bootsraps with shuffled -s file
                              Default = 100 for faster runs; use higher -n for good pvalues 
                              (-n 10000 is best for permutation test but this will take a while)
                              If set to 0, no bootstrap will be done
    -b,--build    => (BOOL)   See above; use this and provide the genome fasta file if no range/lengths file (-r)
                              This step may take a while but will create the required file	
    -d,--dogaps   => (BOOL)   See above; use this and provide the genome fasta file if no gap file (-g)
                              If several files in -e, then the genome needs to be the first one.
                              This step is not optimized, it will take a while (but will create the required file)                       
    -i,--incl     => (STRING) To use as -incl for bedtools shuffle: \"coordinates in which features from -i should be placed.\"
                              Bed of gff format. Could be intervals close to TSS for example.
                              More than one file (same format) may be provided (comma separated), 
                              they will be concatenated (in a file = first-file-name.cat.bed)
    -a,--add      => (BOOL)   to add the -noOverlapping option to the bedtools shuffle command line, 
                              and therefore NOT allow overlaps between the shuffled features.
                              This may create issues mostly if -i is used (space to shuffle into smaller than features to shuffle)
    -l,--low      => (STRING) To set the behavior regarding non TE sequences: all, no_low, no_nonTE, none
                                 -t all = keep all non TE sequences (no filtering)
                                 -t no_low [default] = keep all besides low_complexity and simple_repeat
                                 -t no_nonTE = keep all except when class = nonTE
                                 -t none = everything is filtered out (nonTE, low_complexity, simple_repeat, snRNA, srpRNA, rRNA, tRNA/tRNA, satellite)
    -t,--te       => (STRING) <type,name>
                              run the script on only a subset of repeats. Not case sensitive.
                              The type can be: name, class or family and it will be EXACT MATCH unless -c is chosen as well
                              ex: -a name,nhAT1_ML => only fragments corresponding to the repeat named exactly nhAT1_ML will be looked at
                                  -a class,DNA => all repeats with class named exactly DNA (as in ...#DNA/hAT or ...#DNA/Tc1)
                                  -a family,hAT => all repeats with family named exactly hAT (so NOT ...#DNA/hAT-Charlie for example)
    -c,--contain  => (BOOL)   to check if the \"name\" determined with -filter is included in the value in Repeat Masker output, instead of exact match
                              ex: -a name,HERVK -c => all fragments containing HERVK in their name
                                  -a family,hAT -c => all repeats with family containing hAT (...#DNA/hAT, ...#DNA/hAT-Charlie, etc)
    -w,--where    => (STRING) if BEDtools are not in your path, provide path to BEDtools bin directory
    -v,--version  => (BOOL)   print the version
    -h,--help     => (BOOL)   print this usage
\n";

#-----------------------------------------------------------------------------
#------------------------------ LOAD AND CHECK -------------------------------
#-----------------------------------------------------------------------------

my ($input,$shuffle,$exclude,$dogaps,$build,$dobuild,$catout,$rprint,$f_regexp,$allow,$nooverlaps,$v,$help);
my $inters = 10;
my $nboot = 10;
my $incl = "na";
my $nonTE = "no_low";
my $filter = "na";
my $bedtools = "";
my $opt_success = GetOptions(
			 	  'feat=s'		=> \$input,
			 	  'shuffle=s'   => \$shuffle,
			 	  'overlap=s'   => \$inters,
			 	  'nboot=s'     => \$nboot,
			 	  'range=s'     => \$build,
			 	  'build'       => \$dobuild,
			 	  'excl=s'		=> \$exclude,
			 	  'dogaps'      => \$dogaps,
			 	  'incl=s'		=> \$incl,
			 	  'add'		    => \$nooverlaps,
			 	  'low=s'		=> \$nonTE,
			 	  'te=s'		=> \$filter,
			 	  'contain'     => \$f_regexp,
			 	  'where=s'     => \$bedtools,
			 	  'version'     => \$v,
			 	  'help'		=> \$help,);

#Check options, if files exist, etc
die "\n --- $scriptname version $version\n\n" if $v;
die $usage if ($help);
die "\n SOME MANDATORY ARGUMENTS MISSING, CHECK USAGE:\n$usage" if (! $input || ! $shuffle || ! $build || ! $exclude);
die "\n -f $input is not a bed file?\n\n" unless ($input =~ /\.bed$/);
die "\n -l $input does not exist?\n\n" if (! -e $input);
die "\n -s $shuffle is not in a proper format (not .out, .bed, .gff or .gff3)?\n\n" unless (($shuffle =~ /\.out$/) || ($shuffle =~ /\.bed$/) || ($shuffle =~ /\.gff$/) || ($shuffle =~ /\.gff3$/));
die "\n -s $shuffle does not exist?\n\n" if (! -e $shuffle);
die "\n -r $build does not exist?\n\n" if (! -e $build);
die "\n -e $exclude does not exist?\n\n" if (($exclude !~ /,/) && (! -e $exclude)); #if several files, can't check existence here
die "\n -i $incl does not exist?\n\n" if (($incl ne "na") && ($incl !~ /,/) && (! -e $incl)); #if several files, can't check existence here
die "\n -n $nboot but should be an integer\n\n" if ($nboot !~ /\d+/);
die "\n -i $inters but should be an integer\n\n" if ($inters !~ /\d+/);
die "\n -w $bedtools does not exist?\n\n" if (($bedtools ne "") && (! -e $bedtools));
die "\n -t requires 2 values separated by a coma (-t <name,filter>; use -h to see the usage)\n\n" if (($filter ne "na") && ($filter !~ /,/));
($dogaps)?($dogaps = "y"):($dogaps = "n");
($dobuild)?($dobuild = "y"):($dobuild = "n");
($f_regexp)?($f_regexp = "y"):($f_regexp="n");
$bedtools = $bedtools."/" if (($bedtools ne "") && (substr($bedtools,-1,1) ne "/")); #put the / at the end of path if not there
($nooverlaps)?($nooverlaps = "-noOverlapping"):($nooverlaps = "");

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
print STDERR "\n --- $scriptname v$version\n";

#Genome range
print STDERR " --- loading build (genome range)\n";
my ($okseq,$build_file) = load_build($build,$dobuild);

#Files to exclude for shuffling
print STDERR " --- getting ranges to exclude in the shuffling of features from $exclude\n";
my @exclude = ();
if ($exclude =~ /,/) {
	($dogaps eq "y")?(print STDERR "     several files provided, -d chosen, genome file (fasta) should be the first one\n"):
	                 (print STDERR "     several files provided, assembly gaps should be the first one\n");
	@exclude = split(",",$exclude) if ($exclude =~ /,/);
} else {
	$exclude[0] = $exclude;
}
$exclude[0] = load_gap($exclude[0],$dogaps);
print STDERR "     concatenating files for -e\n" if ($exclude =~ /,/);
my $excl;
($exclude =~ /,/)?($excl = concat_beds(\@exclude)):($excl = $exclude[0]);

#If relevant, files to include for shuffling
if (($incl ne "na") && ($incl =~ /,/)) {
	print STDERR " --- concatenating $incl files to one file\n";
	my @include = split(",",$incl);
	$incl = concat_beds(\@include);
}

#Now features to shuffle
print STDERR " --- checking file in -s, print in .bed if not a .bed or gff file\n";
print STDERR "     filtering TEs based on filter ($filter) and non TE behavior ($nonTE)\n" unless ($filter eq "na");
print STDERR "     + getting genomic counts for each repeat\n";
my ($toshuff_file,$parsedRM) = RMtobed($shuffle,$okseq,$filter,$f_regexp,$nonTE);

#Outputs
my $stats;
my ($f_type,$f_name) = split(",",$filter) unless ($filter eq "na");	
($filter eq "na")?($stats = "$input.nonTE-$nonTE.$nboot.boot.stats"):($stats = "$input.nonTE-$nonTE.$f_name.$nboot.boot.stats");		
my ($out,$outb,$temp,$temp_s) = ("$input.no_boot","$input.boot","$input.temp","$toshuff_file.temp");
cleanup_out($out,$outb,$stats,$temp,$temp_s,$nboot,$input);

#Get total number of features in input file (= counting number of lines with stuff in it)
print STDERR " --- Getting number and length of input\n";
my $input_feat = get_features_info($input);
print STDERR "     number of features = $input_feat->{'nb'}\n";

#Join -i file with -s
my $intersectBed = $bedtools."intersectBed";
print STDERR " --- Intersect with command lines:\n";
print STDERR "        $intersectBed -a $toshuff_file -b $input -wo > $temp/no_boot.joined\n";
system "$intersectBed -a $toshuff_file -b $input -wo > $temp/no_boot.joined";

#Process the joined files
print STDERR " --- Check intersections of $input with features in $toshuff_file (observed)\n";
my $no_boot;
$no_boot = check_for_overlap("$temp/no_boot.joined","no_boot",$out,$inters,$input_feat,$no_boot);

#Now bootstrap runs
print STDERR " --- Run $nboot bootstraps now (to get significance of the overlaps)\n";
print STDERR "     with intersect command line similar to the one above, and shuffle command line:\n";
($incl eq "na")?(print STDERR "        ".$bedtools."shuffleBed -i $toshuff_file -excl $excl -f 2 $nooverlaps -g $build -chrom -maxTries 10000\n"):
                (print STDERR "        ".$bedtools."shuffleBed -incl $incl -i $toshuff_file -excl $excl -f 2 $nooverlaps -g $build -chrom -maxTries 10000\n");
my $boots = ();
if ($nboot > 0) {
	foreach (my $i = 1; $i <= $nboot; $i++) {
		print STDERR "     ..$i bootstraps done\n" if (($i == 10) || ($i == 100) || ($i == 1000) || (($i > 1000) && (substr($i/1000,-1,1) == 0)));	
#		print STDERR " --- BOOTSTRAP $i\n";	
#		print STDERR "     Shuffle features with command line:\n";
		my $shuffled = shuffle($toshuff_file,$temp_s,$i,$excl,$incl,$build_file,$bedtools,$nooverlaps);
#		print STDERR " --- Intersect with command lines:\n";
#		print STDERR "      $intersectBed -a $shuffled -b $input -wo > $temp/boot.$i.joined\n";
		system "      $intersectBed -a $shuffled -b $input -wo > $temp/boot.$i.joined";
#		print STDERR "   - Check intersections of $input with features in $shuffled (expected)\n";
		$boots = check_for_overlap("$temp/boot.$i.joined","boot.".$i,$outb,$inters,$input_feat,$boots);
		`cat $outb >> $outb.CAT.boot.txt` if (-e $outb);
		`rm -Rf $temp/boot.$i.joined $shuffled`; #these files are now not needed anymore, all is stored
	}
}
`rm -Rf $temp $temp_s`; #these folders are not needed anymore


#Stats now
print STDERR " --- Get and print stats\n" if ($nboot > 0);
print_stats($stats,$no_boot,$boots,$nboot,$input_feat,$parsedRM,$scriptname,$version) if ($nboot > 0);

#end
print STDERR " --- $scriptname done\n";
print STDERR "     Stats printed in: $stats.txt\n" if ($nboot > 0);
print STDERR "\n";
exit;


#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Get build if needed and get chromosomes included in it
# my ($okseq,$build_file) = load_build($build,$dobuild);
#-----------------------------------------------------------------------------
sub load_build{ 
    my ($file,$dobuild) = @_;
    my %build = ();
    my $build_file;
    if ($dobuild eq "n") {
    	$build_file = $file;
		open (my $in, '<', $file) or confess "ERROR (sub load_build): can't open to read $file $!\n";
		GAP_LINE: while(<$in>){
			chomp;
			my @l = split /\t/, $_;
			$build{$l[0]} = $l[1]; 
		}
		close $in;
    } else {
		print STDERR "     printing chrom. range file for $file\n";
    	$build_file = $file.".build.tab";
    	open (my $lenfh, ">", $build_file) or confess "ERROR (sub load_build): can't open to write $build_file $!\n";
		my $fa = Bio::SeqIO->new(-file => $file, -format => "fasta") or confess "ERROR (sub parse_build): can not open as fasta object $file $!\n";
		my %replen = ();
		while( my $seq = $fa->next_seq() ) {
			my $name = $seq->display_id;
			my $len = $seq->length;
			$build{$name} = $len;
			print $lenfh "$name\t$len\n";
		}
		undef $fa;
		close $lenfh;    
    }
    return (\%build,$build_file);
}

#-----------------------------------------------------------------------------
# loading assembly gaps
# my $excl = load_gap($gaps,$dogaps);
#-----------------------------------------------------------------------------
sub load_gap {
    my ($file,$dogaps) = @_;
    my $bed;  
	if ($dogaps eq "y") { 
	    #gaps not in file yet, get them from fasta file in bed format
		$bed = print_gap_bed($file);
	} else {
		print STDERR "     printing bed file corresponding to assembly gaps in $file (limiting to features > 50nt)\n";
		#file with gaps, check if bed already
		($file =~ /\.bed$/)?($bed = $file):($bed = $file.".bed");
		if ($file !~ /\.bed$/) {
			open (my $in, '<', $file) or confess "ERROR (sub gap_file): can't open to read $file $!\n";
			open (my $out, '>', $bed) or confess "ERROR (sub gap_file): can't open to write $bed $!\n";
			LINE: while(<$in>){
				chomp(my $l = $_);
				next LINE if (substr($l,0,1) eq "#");
				my @l = split(/\t/,$l);			
				#bin, chrom, chromStart, chromEnd, ix, n, size, type, bridge)
				print $out "$l[1]\t$l[2]\t$l[3]\n" unless ($l[3]-$l[2] < 50);
			}
		close $in;
		close $out;
		}
	}
    return ($bed);
}

#-----------------------------------------------------------------------------
# printing assembly gaps if needed, in bed format
# $file = print_gap($file) if ($ifbuild eq "n");
#-----------------------------------------------------------------------------
sub print_gap_bed {
	my $file = shift;
	print STDERR "     loading assembly gaps from $file (stretches of Ns > 50nt)\n";
	my $fasta = Bio::SeqIO->new(-file => $file, -format => "fasta") or confess "ERROR (sub print_gap_bed): failed to create SeqIO object from $file $!\n";
	my $gaps = "$file.gaps.bed";
	open my $gapfh, ">", $gaps or confess "ERROR (sub print_gap): could not open to write $gaps $!\n";
	while( my $seqfa = $fasta->next_seq() ) {
		my $head = $seqfa->display_id;
		my $seq = $seqfa->seq;
		$seq = uc($seq); #uppercases just in case
		my @seq = split("",$seq);
		my $Nstart = 0;
		my $Nlen = 0;
		NUCL: for (my $i = 0; $i <= $#seq; $i++){
			#go to next nt if this is not a gap to extend or first nt after a gap
			my $nt = $seq[$i];
			next NUCL if (($nt ne "N") && ($Nlen == 0));
			if ($nt eq "N") {
				$Nstart = $i+1 if ($Nlen == 0); #do not increment if extending gap
				$Nlen++; #will be 1 if was 0
			} else { #end of a gap, print and reintialize (already skipped if length is < 10)
				my $Nend = $Nlen + $Nstart - 1;
				print $gapfh "$head\t$Nstart\t$Nend\n" unless ($Nlen < 10);
				$Nstart = 0;
				$Nlen = 0;
			}
		}
	}
	undef $fasta;
	close $gapfh;
	return ($gaps);
}

#-----------------------------------------------------------------------------
# Concatenate files with cat
# my $excl = concat_beds(\@exclude) if ($exclude =~ /,/);
# $incl = concat_beds(\@include);
#-----------------------------------------------------------------------------
sub concat_beds {
	my $files = shift;
	my $concat = $files->[0].".cat.bed";
	my $list = "";
	foreach my $file (@{$files}) {
		#system "sed -i -e '$a\' $file"; #add newline if not one, otherwise it will create issues with cat, but problem here with the $, perl is looking for a variable
		my $check = `tail -1 $file | wc -l`;
		chomp($check);
		`echo >> $file` if ($check == 0);
		print STDERR "     $file has no newline at the end (tail -1 $file | wc -l returned $check)\n" if ($check == 0);
		$list = $list." $file";
	}
	`cat $list > $concat`;
	return ($concat);
}

#-----------------------------------------------------------------------------
# Convert RMoutput .out file to bed if needed
# my ($toshuff_file,$parsedRM) = RMtobed($shuffle,$okseq,$filter,$f_regexp,$nonTE);
#-----------------------------------------------------------------------------
sub RMtobed {
	my ($file,$okseq,$filter,$f_regexp) = @_;
	my $parsed = ();
	my ($f_type,$f_name) = split(",",$filter) unless ($filter eq "na");	
	my $ok = $file;
	$ok = $1 if ($file =~ /(.*)\.out$/);	
	$ok = $1 if ($file =~ /(.*)\.bed$/);	
	($filter eq "na")?($ok = $ok.".nonTE-$nonTE.bed"):($ok = $ok.".$f_name.bed");		
	if (-e $ok) { #if has been filtered same way, OK, just get dictionary
		print STDERR "     -> $ok exists, just getting dictionary from it\n";
		$parsed = getparsedRM($ok,$parsed,"file");
		return ($ok,$parsed);
	}
	print STDERR "     -> $file is in bed format, but $ok does not exist; generating it...\n" if ($file =~ /(.*)\.bed$/);
	#now it means RM.out, or that the proper bed file does not exist => make it a bed file + load the parsing hash	
	open(my $fh, "<$file") or confess "\n   ERROR (sub RMtobed): could not open to read $file!\n";
	open(my $bed_fh, ">$ok") or confess "\n   ERROR (sub RMtobed): could not open to write $ok!\n";
	LINE: while(<$fh>) {
		chomp(my $l = $_);
		my @l = ();
		my ($Rname,$classfam);
		if ($file =~ /(.*)\.out$/) { #if .out	
			$l =~ s/^\s+//;
			next LINE if (($l =~ /^[Ss]core|^SW|^#/) || ($l !~ /\w/));
			$l = $1 if ($l =~ /^(.*)\*$/); #remove the star
			@l = split('\s+',$l);			
		} else { #if .bed file
			my @all = split('\s+',$l);
			@l = split(";",$all[3]);
		}	
		next LINE unless (defined $okseq->{$l[4]}); #if not in build of stuff OK to shuffle on, remove here as well
		$l[8] =~ s/C/-/; #correct strand to match convention
		($Rname,$classfam) = ($l[9],$l[10]);	
		my ($Rclass,$Rfam) = get_Rclass_Rfam($Rname,$classfam);
		
		#now filter non TE or not, based on -nonTE value
		next LINE if (($nonTE eq "none") && ($Rclass =~ /nonTE|snRNA|rRNA|tRNA|snoRNA|scRNA|srpRNA|[Ll]ow_complexity|[Ss]imple_repeat|[Ss]atellite/));
		next LINE if (($nonTE eq "no_nonTE") && ($Rclass =~ /nonTE/));
		next LINE if (($nonTE eq "no_low") && ($Rclass =~ /[Ll]ow_complexity|[Ss]imple_repeat/));

		#filter out stuff from -filter if relevant
		if ($filter ne "na") {				
			if ($f_regexp eq "y") {
				#check if what's det as the filter is included in the names
				next LINE unless ((($f_type eq "name") && ($Rname =~ /$f_name/))
							   || (($f_type eq "class") && ($Rclass =~ /$f_name/)) 
							   || (($f_type eq "family") && ($Rfam =~ /$f_name/)));
			} else {
				next LINE unless ((($f_type eq "name") && ($f_name eq $Rname))
							   || (($f_type eq "class") && ($f_name eq $Rclass)) 
							   || (($f_type eq "family") && ($f_name eq $Rfam)));
			}	
		}
		
		#create unique ID = the RMout line
		my ($chr,$start,$end,$strand) = ($l[4],$l[5],$l[6],$l[8]);
		my $ID = $l[0];
		for (my $i=1; $i<=$#l;$i++) {
			$ID = $ID.";".$l[$i];
		}
		$ID =~ s/\s//; #should not need this, but just in case
		
# 		#correct the start if base is 0
# 		$start=$start+1 if ($base == 0);
		
		#print in bed format
		print $bed_fh "$chr\t$start\t$end\t$ID\t.\t$strand\n"; #with ID being the whole line => easy to acces to RMoutput original info
		
		#get dictionary
		$parsed = getparsedRM(\@l,$parsed,"line");
	}
	close ($fh);
	close ($bed_fh);
	return ($ok,$parsed);
}

#-----------------------------------------------------------------------------
# Get infos from RMout
# $parsed = getparsedRM($file,$parsed,"file");
# $parsed = getparsedRM(\@l,$parsed,"line");
#-----------------------------------------------------------------------------
sub getparsedRM {
	my ($info,$parsed,$type) = @_;
	if ($type eq "line") { #meaning it's read from the .out while being converted in .bed
		$parsed = getparsedRMline($parsed,$info);
	} else { #meaning it's already a bed file => open and read it
		open(my $fh, "<$info") or confess "\n   ERROR (sub getparsedRM): could not open to read $info!\n";
		LINE: while(<$fh>) {
			chomp(my $l = $_);
			$l =~ s/^\s+//;
			next LINE if (($l =~ /^[Ss]core|^SW|^#/) || ($l !~ /\w/));
			my @l = split('\s+',$l);
			my @RMline = split(";",$l[3]);
			$parsed = getparsedRMline($parsed,\@RMline);
		}
		close $fh;	
	}
	return($parsed);
}

#-----------------------------------------------------------------------------
# Get counts and length for each TE
# $parsed = getparsedRMline($parsed,$info)
# $parsed = getparsedRMline($parsed,\@RMline)
#-----------------------------------------------------------------------------
sub getparsedRMline {
	my ($parsed,$l) = @_;
	my ($Rname,$classfam) = ($l->[9],$l->[10]);
	my ($Rclass,$Rfam) = get_Rclass_Rfam($Rname,$classfam);
	#now feed dictionary
	($parsed->{'tot'}{'tot'}{'tot'})?($parsed->{'tot'}{'tot'}{'tot'}++):($parsed->{'tot'}{'tot'}{'tot'}=1);
	($parsed->{$Rclass}{'tot'}{'tot'})?($parsed->{$Rclass}{'tot'}{'tot'}++):($parsed->{$Rclass}{'tot'}{'tot'}=1);
	($parsed->{$Rclass}{$Rfam}{'tot'})?($parsed->{$Rclass}{$Rfam}{'tot'}++):($parsed->{$Rclass}{$Rfam}{'tot'}=1);
	($parsed->{$Rclass}{$Rfam}{$Rname})?($parsed->{$Rclass}{$Rfam}{$Rname}++):($parsed->{$Rclass}{$Rfam}{$Rname}=1);
	return $parsed;
}

#-----------------------------------------------------------------------------
# Cleanup previous outputs
# cleanup_out($out,$outb,$stats,$temp,$temp_s,$nboot);
#-----------------------------------------------------------------------------
sub cleanup_out {
	my ($out,$outb,$stats,$temp,$temp_s,$nboot) = @_;
	`mv $out $out.previous` if (-e $out);
	`mv $outb $outb.previous` if (-e $outb);
	`mv $stats.txt $stats.txt.previous` if (-e $stats.".txt");
	`mv $stats.details.txt $stats.details.txt.previous` if (-e $stats.".details.txt");
	`mv $outb.CAT.boot.txt $outb.CAT.boot.txt.previous` if (-e $outb.".CAT.boot.txt");
	`mv $out.Rname $out.Rname.previous` if (-e $out.".Rname");
	`mv $out.Rfam $out.Rfam.previous` if (-e $out.".Rfam");
	`mv $out.Rclass $out.Rclass.previous` if (-e $out.".Rclass");
	`mv $outb.Rname $outb.Rname.previous` if (-e $outb.".Rname");
	`mv $outb.Rfam $outb.Rfam.previous` if (-e $outb.".Rfam");
	`mv $outb.Rclass $outb.Rclass.previous` if (-e $outb.".Rclass");
	`rm -Rf $temp` if (-e $temp);
	`rm -Rf $temp_s` if (-e $temp_s);
	`mkdir $temp`;
	`mkdir $temp_s` if ($nboot > 0);
	return 1;
}	

#-----------------------------------------------------------------------------
# Get input file info
# my $input_feat = get_features_info($input);
#-----------------------------------------------------------------------------
sub get_features_info {
	my $file = shift;
	my %info = ();		
	my $nb = `grep -c -E "\\w" $file`;
#	my $len = `more $file | awk '{SUM += (\$3-\$2)} END {print SUM}'`; #this assumes no overlaps, trusting user for now
	chomp($nb);
#	chomp($len);
	$info{'nb'} = $nb;
#	$info{'len'} = $len;				
	return(\%info);
}

#-----------------------------------------------------------------------------
# Shuffle, with bedtools
# my $shuffled = shuffle($toshuff_file,$temp_s,$i,$excl,$incl,$build_file,$bedtools,$nooverlaps);
#-----------------------------------------------------------------------------
sub shuffle {
	my ($toshuff_file,$temp_s,$nb,$excl,$incl,$build,$bedtools,$nooverlaps) = @_;
	my $out = $temp_s."/shufffled".$nb;
	my $bed_shuffle = $bedtools."shuffleBed";
#  	($incl eq "na")?(print STDERR "      $bed_shuffle -i $toshuff_file -excl $excl -f 2 $shuff_allow_overlaps -g $build -chrom -maxTries 10000 > $out\n"):
#  	                (print STDERR "      $bed_shuffle -incl $incl -i $toshuff_file -excl $excl -f 2 $shuff_allow_overlaps -g $build -chrom -maxTries 10000 > $out\n");
	($incl eq "na")?(system "$bed_shuffle -i $toshuff_file -excl $excl -f 2 $nooverlaps -g $build -chrom -maxTries 10000 > $out"):
	                (system "$bed_shuffle -incl $incl -i $toshuff_file -excl $excl -f 2 $nooverlaps -g $build -chrom -maxTries 10000 > $out");	
	return ($out);

}

#-----------------------------------------------------------------------------
# Check overlap with TEs and count for all TEs
# $no_boot = check_for_overlap("$temp/no_boot.joined","no_boot",$out,$inters,$input_feat,$no_boot,$no_boot_feat_hit);
# $boots = check_for_overlap("$temp/boot.$i.joined","boot.".$i,$outb,$inters,$input_feat,$boots);
#-----------------------------------------------------------------------------
sub check_for_overlap {
	my ($file,$fileid,$out,$inters,$input_feat,$counts) = @_;
	my $p = ();	
	#now loop
	open(my $fh, "<$file") or confess "\n   ERROR (sub check_for_overlap): could not open to read $file!\n";
	LINE: while(<$fh>){
		chomp(my $l = $_);
		#FYI:
		# chr1	4522383	4522590	1111;18.9;4.6;1.0;chr1;4522383;4522590;(190949381);-;B3;SINE/B2;(0);216;1;1923	.	-	chr1	4496315	4529218	[ID] [score] [strand]
		my @l = split(/\s+/,$l);	
		my $ilen = $l[-1]; #last value of the line is intersection length
		next LINE unless ($ilen >= $inters);
		my @rm = split(";",$l[3]);
		my $Rnam = $rm[9];
		my ($Rcla,$Rfam) = get_Rclass_Rfam($Rnam,$rm[10]);
		#now increment in the data structure		
		($counts->{$fileid}{'tot'}{'tot'}{'tot'}{'tot'})?($counts->{$fileid}{'tot'}{'tot'}{'tot'}{'tot'}++):($counts->{$fileid}{'tot'}{'tot'}{'tot'}{'tot'}=1);
		($counts->{$fileid}{$Rcla}{'tot'}{'tot'}{'tot'})?($counts->{$fileid}{$Rcla}{'tot'}{'tot'}{'tot'}++):($counts->{$fileid}{$Rcla}{'tot'}{'tot'}{'tot'}=1);
		($counts->{$fileid}{$Rcla}{$Rfam}{'tot'}{'tot'})?($counts->{$fileid}{$Rcla}{$Rfam}{'tot'}{'tot'}++):($counts->{$fileid}{$Rcla}{$Rfam}{'tot'}{'tot'}=1);
		($counts->{$fileid}{$Rcla}{$Rfam}{$Rnam}{'tot'})?($counts->{$fileid}{$Rcla}{$Rfam}{$Rnam}{'tot'}++):($counts->{$fileid}{$Rcla}{$Rfam}{$Rnam}{'tot'}=1);		
	}
	close ($fh);		
	#Now print stuff and exit
#	print STDERR "     print details in files with name base = $out\n";	
	print_out($counts,$fileid,$input_feat,$out);	
	return ($counts);
}

#----------------------------------------------------------------------------
# Get class fam
# my ($Rclass,$Rfam) = get_Rclass_Rfam($Rname,$classfam);
#----------------------------------------------------------------------------
sub get_Rclass_Rfam {
	my($Rname,$classfam) = @_;
	my ($Rclass,$Rfam);
	if ($classfam =~ /\//) {
		my $incaseof;
		($Rclass,$Rfam,$incaseof) = split(/\//, $classfam); #should not happen but in case there was a / in family
		$Rfam = $Rfam."_".$incaseof if ($incaseof);
	} else {
		$Rfam = $classfam;
		$Rfam=~ s/^(.*)\..*$/$1/;
		$Rclass = $classfam;
		$Rclass =~ s/^.*\.(.*)$/$1/;
	}
	$Rfam = $Rfam."--int" if (($Rfam =~ /ERV/) && (($Rname =~ /[-_][iI]nt/) || ($Rname =~ /[-_]I$/)));
	return ($Rclass,$Rfam);
}

#-----------------------------------------------------------------------------
# Print out details of boot and no_boot stuff
# print_out($counts,$feat_hit,$fileid,$type,$out);
#-----------------------------------------------------------------------------
sub print_out {
	my ($counts,$fileid,$input_feat,$out) = @_;	
	foreach my $Rclass (keys %{$counts->{$fileid}}) {
		print_out_sub($fileid,$Rclass,"tot","tot",$counts,$input_feat,$out.".Rclass");
		foreach my $Rfam (keys %{$counts->{$fileid}{$Rclass}}) {
			print_out_sub($fileid,$Rclass,$Rfam,"tot",$counts,$input_feat,$out.".Rfam");
			foreach my $Rname (keys %{$counts->{$fileid}{$Rclass}{$Rfam}}) {						
				print_out_sub($fileid,$Rclass,$Rfam,$Rname,$counts,$input_feat,$out.".Rname");
			}
		}
	}
    return 1;
}

#-----------------------------------------------------------------------------
# Print out details of boot and no_boot stuff, bis
#-----------------------------------------------------------------------------
sub print_out_sub {
	my ($fileid,$key1,$key2,$key3,$counts,$input_feat,$out) = @_;
	my $tothit = $counts->{$fileid}{'tot'}{'tot'}{'tot'}{'tot'};	
	my $hit = $counts->{$fileid}{$key1}{$key2}{$key3}{'tot'};
	my $unhit = $input_feat->{'nb'}-$hit;
	my $len = $counts->{$fileid}{$key1}{$key2}{$key3}{'len'}{'tot'};
	open (my $fh, ">>", $out) or confess "ERROR (sub print_out_sub): can't open to write $out $!\n";
				#fileid, class, fam, name, hits, total features loaded, unhit feat, total feat hit all categories, len
	print $fh "$fileid\t$key1\t$key2\t$key3\t$hit\t$input_feat->{'nb'}\t$unhit\t$tothit\tlen\n";
	close $fh;
    return 1;
}

#-----------------------------------------------------------------------------
# Print Stats (permutation test basically) + associated subroutines
# print_stats($stats,$no_boot,$boots,$nboot,$input_feat,$parsedRM,$scriptname,$version) if ($nboot > 0);
#-----------------------------------------------------------------------------
sub print_stats {
	my ($out,$obs,$boots,$nboot,$input_feat,$parsedRM,$scriptname,$version) = @_;
	
	#get the boot avg values, sds, agregate all values
	#For obs, just have first key = no_boot
	my $exp = get_stats_data($boots,$nboot,$obs,$out,$input_feat,$parsedRM);
	
	#now print; permutation test + binomial test with avg lengths
	my $midval = $nboot/2;
	open (my $fh, ">", $out.".txt") or confess "ERROR (sub print_stats): can't open to write $out.txt $!\n";	
	print $fh "#Script $scriptname, v$version\n";
	print $fh "#Aggregated results + stats\n";
#	print $fh "#Features in input file:\n\t$input_feat->{'nb'}\t(counts)\tand\t$input_feat->{'len'}\t(amount of DNA)\n";
	print $fh "#Features in input file (counts):\n\t$input_feat->{'nb'}\n";
	print $fh "#With $nboot bootstraps for exp (expected); sd = standard deviation; nb = number; len = length; avg = average\n";
	print $fh "#Two tests are made (permutation and binomial) to assess how significant the difference between observed and random, so two pvalues are given\n";
	print $fh "#The binomial test is not 2 sided, so it only tests for enrichment in observed values\n";
	print $fh "#A pvalue cannot be 0, so when the probability is 1 (meaning enrichment of this repeat in the observed set), pvalue is set to na, but the significance is ***\n";
	print $fh "#For the two tailed permutation test:\n";
	print $fh "#if rank is < $midval and pvalue is not \"ns\", there are significantly fewer observed values than expected \n";
	print $fh "#if rank is > $midval and pvalue is not \"ns\", there are significantly higher observed values than expected \n";
	print $fh "\n#Level_(tot_means_all)\t#\t#\t#COUNTS\t#\t#\t#\t#\t#\t#\t#\t#\t#\t#\t#\t#\t#\n";
	print $fh "#Rclass\tRfam\tRname\tobs_nb_of_hits\t%_obs_nb_(%of_features)\tobs_tot_nb_of_hits\texp_nb_avg_of_hits\texp_nb_sd\t%_exp_nb_(%of_features)\texp_tot_nb_of_hits(avg)\tobs_rank_in_exp\t2-tailed_permutation-test_pvalue(obs.vs.exp)\tsignificance\tnb_binomal_test_proba(obs.vs.exp)\tnb_binomal_test_pvalue(1-proba)\tsignificance\tobs_len\t%_obs_len_(%of_features)\tobs_tot_len\texp_len_avg\texp_len_sd\t%_exp_len_(%of_features)\texp_tot_len(avg)\tobs_rank_in_exp\t2-tailed_permutation-test_pvalue(obs.vs.exp)\tsignificance\tlen_binomal_test_proba(obs.vs.exp)\tlen_binomal_test_pvalue(1-proba)\tsignificance\n\n";

	foreach my $Rclass (keys %{$exp}) { #loop on all the repeat classes; if not in the obs then it will be 0 for obs values			
		foreach my $Rfam (keys %{$exp->{$Rclass}}) {			
			foreach my $Rname (keys %{$exp->{$Rclass}{$Rfam}}) {
				#observed
				my ($obsnb,$obsper) = (0,0);
				$obsnb = $obs->{'no_boot'}{$Rclass}{$Rfam}{$Rname}{'tot'} if ($obs->{'no_boot'}{$Rclass}{$Rfam}{$Rname}{'tot'});
				$obsper = $obsnb/$input_feat->{'nb'}*100 unless ($obsnb == 0);
				#expected
				my $expper = 0;
				my $expavg = $exp->{$Rclass}{$Rfam}{$Rname}{'avg'};	
				$expper = $expavg/$input_feat->{'nb'}*100 unless ($expavg == 0);
				#stats
				my $pval_nb = $exp->{$Rclass}{$Rfam}{$Rname}{'pval'};		
				$pval_nb = "na" if (($expavg == 0) && ($obsnb == 0));		
								
				#Now print stuff
				print $fh "$Rclass\t$Rfam\t$Rname\t";
				print $fh "$obsnb\t$obsper\t$obs->{'no_boot'}{'tot'}{'tot'}{'tot'}{'tot'}\t"; 
				print $fh "$expavg\t$exp->{$Rclass}{$Rfam}{$Rname}{'sd'}\t$expper\t$exp->{'tot'}{'tot'}{'tot'}{'avg'}\t";			
				my $sign = get_sign($pval_nb);				
				print $fh "$exp->{$Rclass}{$Rfam}{$Rname}{'rank'}\t$pval_nb\t$sign\t";
				$exp->{$Rclass}{$Rfam}{$Rname}{'binom_proba'} = "na" unless ($exp->{$Rclass}{$Rfam}{$Rname}{'binom_proba'});
				$exp->{$Rclass}{$Rfam}{$Rname}{'binom_pval'} = "na" unless ($exp->{$Rclass}{$Rfam}{$Rname}{'binom_pval'});
				$sign = get_sign($exp->{$Rclass}{$Rfam}{$Rname}{'binom_pval'});
				$sign = "***" if ($exp->{$Rclass}{$Rfam}{$Rname}{'binom_proba'} == 1);
				print $fh "$exp->{$Rclass}{$Rfam}{$Rname}{'binom_proba'}\t$exp->{$Rclass}{$Rfam}{$Rname}{'binom_pval'}\t$sign\n";	
			}
		}
	}
	close $fh;
    return 1;
}

#-----------------------------------------------------------------------------
# Get the stats values 
# my $exp = get_stats_data($boots,$nboot,$obs,$out,$input_feat,$parsedRM);
#-----------------------------------------------------------------------------
sub get_stats_data {
	my ($counts,$n,$obs,$out,$input_feat,$parsedRM) = @_;
	my $exp = ();

	#agregate data
	my ($nb_c,$len_c,$nb_f,$len_f,$nb_r,$len_r) = ();
	foreach my $round (keys %{$counts}) {
		foreach my $Rclass (keys %{$counts->{$round}}) {
			push(@{$nb_c->{$Rclass}{'tot'}{'tot'}},$counts->{$round}{$Rclass}{'tot'}{'tot'}{'tot'});	
			foreach my $Rfam (keys %{$counts->{$round}{$Rclass}}) {
				push(@{$nb_f->{$Rclass}{$Rfam}{'tot'}},$counts->{$round}{$Rclass}{$Rfam}{'tot'}{'tot'});	
				foreach my $Rname (keys %{$counts->{$round}{$Rclass}{$Rfam}}) {
					push(@{$nb_r->{$Rclass}{$Rfam}{$Rname}},$counts->{$round}{$Rclass}{$Rfam}{$Rname}{'tot'});	
				}
			}
		}		
	}
	
	#get avg, sd and p values now => load in new hash, that does not have the fileID
	foreach my $round (keys %{$counts}) {
		foreach my $Rclass (keys %{$counts->{$round}}) {
			$exp = get_data($Rclass,"tot","tot",$nb_c->{$Rclass}{'tot'}{'tot'},$exp,$obs,$nboot,$input_feat,$parsedRM);
			foreach my $Rfam (keys %{$counts->{$round}{$Rclass}}) {
				$exp = get_data($Rclass,$Rfam,"tot",$nb_f->{$Rclass}{$Rfam}{'tot'},$exp,$obs,$nboot,$input_feat,$parsedRM);
				foreach my $Rname (keys %{$counts->{$round}{$Rclass}{$Rfam}}) {
					$exp = get_data($Rclass,$Rfam,$Rname,$nb_r->{$Rclass}{$Rfam}{$Rname},$exp,$obs,$nboot,$input_feat,$parsedRM);
				}
			}
		}		
	}
		
	$counts = (); #empty this
	return($exp);
}

#-----------------------------------------------------------------------------
# sub get_data
# called by get_stats_data, to get average, sd, rank and p value for all the lists
#-----------------------------------------------------------------------------	
sub get_data {
	my ($key1,$key2,$key3,$agg_data,$exp,$obs,$nboot,$input_feat,$parsedRM) = @_;	
	#get average and sd of the expected
	($exp->{$key1}{$key2}{$key3}{'avg'},$exp->{$key1}{$key2}{$key3}{'sd'}) = get_avg_and_sd($agg_data);
	
	my $observed = $obs->{'no_boot'}{$key1}{$key2}{$key3}{'tot'};
	print STDERR "FYI: no observed value for {$key1}{$key2}{$key3}{'tot'}\n" unless ($observed);
	$observed = 0 unless ($observed);
	
	
	#Get the rank of the observed value in the list of expected + pvalue for the permutation test
	my $rank = 1; #pvalue can't be 0
	my @data = sort {$a <=> $b} @{$agg_data};
	EXP: foreach my $exp (@data) {
		last EXP if ($exp > $observed);
		$rank++;
	}	
	$exp->{$key1}{$key2}{$key3}{'rank'}=$rank;
	if ($rank <= $nboot/2) {
		$exp->{$key1}{$key2}{$key3}{'pval'}=$rank/$nboot*2;
	} else {
		$exp->{$key1}{$key2}{$key3}{'pval'}=(abs($nboot-$rank))/$nboot*2;
	}
		
	#Binomial test
	# http://search.cpan.org/~callahan/Math-CDF-0.1/CDF.pm
	# $prob = pbinom($x, $n, $p)
	# Generates cumulative probabilities from the Binomial distribution. 
	# This is the probability of having $x or fewer successes in $n trials when each trial has a $p probability of success. 
	# $x should be in the range of [0,$n], $n should be in the range (0,Inf) and $p should be in [0,1].	
	my $n = $parsedRM->{$key1}{$key2}{$key3};
	my $x = $observed;
	my $p = $exp->{$key1}{$key2}{$key3}{'avg'}/$n;
	$exp->{$key1}{$key2}{$key3}{'binom_proba'} = Math::CDF::pbinom($x, $n, $p);
	$exp->{$key1}{$key2}{$key3}{'binom_pval'} = 1 - $exp->{$key1}{$key2}{$key3}{'binom_proba'};	
	return($exp);
}

#-----------------------------------------------------------------------------
# sub get_avg_and_sd
#-----------------------------------------------------------------------------	
sub get_avg_and_sd{
	my($data) = @_;
    warn "WARN: (sub print_stats/get_avg_and_sd): empty data array $!\n" if (not @$data);
    return ($data->[0],"na") if (@$data == 1); #returning 0,0 was an issue if -m =1
        
	my $total = 0;
	foreach (@$data) {
		$total += $_;
	}
	my $avg = $total / @$data;

	my $sqtotal = 0;
	foreach(@$data) {
		$sqtotal += ($avg-$_) ** 2;
	}
	my $sd = ($sqtotal / (@$data-1)) ** 0.5;
	return ($avg,$sd);
}

#-----------------------------------------------------------------------------
# sub get_sign
#-----------------------------------------------------------------------------	
sub get_sign {
	my $pval = shift;
	my $sign;
	if ($pval eq "na") {	
		$sign = "na";
	} else {
		$sign = "ns" if ($pval > 0.05);
		$sign = "*" if ($pval <= 0.05);
		$sign = "**" if ($pval <= 0.01);
		$sign = "***" if ($pval <= 0.001);
	}
	return($sign);
}
