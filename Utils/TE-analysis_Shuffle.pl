#!/usr/bin/perl
#######################################################
# Author  :  Zev Kronenberg (https://github.com/zeeev), for the v1.0
#            Modifications by Aurelie Kapusta (https://github.com/4ureliek) after v2.0
# email   :  4urelie.k@gmail.com  
# Purpose :  Writen to generate data (observed vs expected) shown in Figure 5, 
#            Kapusta et al. 2013 PLoS Genetics
#            (http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1003470)
#######################################################
use strict;
use warnings;
use Carp;
use Getopt::Long;
use Bio::SeqIO;
use GAL::Annotation; #if issues, there is an alternative subroutine not using it, see usage
#use Data::Dumper;

#-----------------------------------------------------------------------------
#------------------------------- DESCRIPTION ---------------------------------
#-----------------------------------------------------------------------------
#flush buffer
$| = 1;

my $version = "3.2";
my $scriptname = "TE-analysis_Shuffle.pl";
my $changelog = "
#	- v1.0 = 2012
#	- v2.0 = Jan 11 2016
#		Too many changes to list here, but concept remains the same
#	- v3.0 = Jan 26 2016
#       Change to bedtools instead of using the Set::IntervalTree perl module. 
#       This means there will be many files printed, but will be much faster
#       However this also means that there will not be a verification that transcripts
#          are located in an acceptable range (not in the -excl file). 
#          Assumes they are OK. Should be though.
#	- v3.1 = Jan 29 2016
#       Delete intermediate files, for space
#	- v3.2 = Feb 03 2016
#       Bug fix in rank (and therefore p value), was inverted (1000 instead of 1)
#       Delete the temp folders
\n";

# TO DO:
#  - allow any bed or gff file for -s

my $usage = "
Synopsis (v$version):

    perl $scriptname -p prot.gff -l lncRNA.gff [-o <X>] [-m <X>] -s features_to_shuffle [-n <X>] -e genome.gaps [-d] -r genome.range [-b] [-i include] [-c <X>] [-t] [-w <bedtools_path>] [-v] [-h]

    /!\\ REQUIRES - Bedtools
	              - GAL::Annotation version later than Jan 2016 [update of is_coding]
	                see https://github.com/The-Sequence-Ontology/GAL
	                If issues, open the script in a text editor and comment line 15,	                
	                as well as the lines with read_gff subroutine, and uncomment lines with subroutine load_gene_tr
	
    /!\\ Previous outputs, if any, will be moved as *.previous [which only saves results once]
  
  CITATION:
    - For the use of this script, Kapusta et al. (2013) PLoS Genetics (DOI: 10.1371/journal.pgen.1003470)
    - for BEDtools, Quinlan AR and Hall IM (2010) Bioinformatics (DOI: 10.1093/bioinformatics/btq033)

  DESCRIPTION:
    Features provided in -s will be overlapped with -p and -l files, 
       without (no_boot) or with (boot) shuffling (on same chromosome)
    A random transcript per gene is selected: use -m to do several repetitions of no_boot
    For each bootstrap (-n) with shuffling features in -s, transcripts are randomly selected as well
    Note that one exon may have several types of overlaps (e.g. \"SPL\" and \"exonized\"),
       but each exon is counted only one time for each category.
       Note that because TEs are often fragmented + there are inversions, the counts for the exonized TEs is likely inflated;
       this could be corrected a tad, but is not for now. Not the major category that is looked at anyway.
       However, this also means that when TEs are shuffled, there are more fragments than TEs; some should be moved non independently, 
       or the input file should be corrected when possible to limit that issue
    Output files columns are as follow:
       transcript_type\tboot_and/or_round_value\toverlap_category\tnb_uniq_exons_in_this_category\ttotal_nb_exons_loaded\tunhit_exons_in_this_category
    Output files can be processed in R (use -print to get an example of command lines with the STDERR)
    This script will also provide pvalues of observed versus expected (permutation test); best pvalues would require 1000 bootstraps
  
  MANDATORY ARGUMENTS:	
    -p,--prot     => (STRING) protein coding gff3 file
    -l,--lnc      => (STRING) lncRNAs gff3 file
    -s,--shuffle  => (STRING) Features to shuffle = TE file
                              For now, can only be the repeat masker .out or the .bed file generated by the TE-analysis_pipeline script                            
                              TO DO = allow any bed or gff file
    -r,--range    => (STRING) To know the maximum value in a given chromosome/scaffold. 
                              File should be: Name \\t length
                              Can be files from UCSC, files *.chrom.sizes
                              If you don't have such file, use -b (--build) and provide the genome fasta file for -r
                               
    -e,--excl     => (STRING) This will be used as -excl for bedtools shuffle: \"coordinates in which features from -i should not be placed.\"
                              Should be either in BED format or be a UCSC gap file (bin, chrom, chromStart, chromEnd, ix, n, size, type, bridge)
                              (detected based on .bed extension at the end of the file name or not)
                              You can get it with this script: https://github.com/4ureliek/DelGet/blob/master/Utilities/fasta_get_gaps.pl
                              If you don't have such file, use -d (--dogaps) and provide the genome fasta file for -e
                              (note that the one from UCSC may contain gaps of lenght = 1 and it will create issues;
                              this script will filter out N stretches of length < 10nt)
	
  OPTIONAL ARGUMENTS:
    -o,--overlap  => (INT)    Minimal length (in nt) of intersection in order to consider the TE included in the feature.
                              Default = 10 (to match the TEanalysis-pipeline.pl)
    -m,--more     => (INT)    Even in the no_boot, a random transcript is picked. Set this number to do repetitions for no_boot.
                              Default = 1 (still need it done 1 time; set this to 0 is equivalent to 1)
    -n,--nboot    => (STRING) number of bootsraps with shuffled -s file
                              Default = 100
                              If set to 0, no bootstrap will be done
    -d,--dogaps   => (BOOL)   See above; use this and provide the genome fasta file if no gap file (-g)
                              This step is not optimized, it will take a while (but will create the required file)
    -b,--build    => (BOOL)   See above; use this and provide the genome fasta file if no range/lengths file (-r)
                              This step may take a while but will create the required file	
    -i,--incl     => (STRING) To use as -incl for bedtools shuffle: \"coordinates in which features from -i should be placed.\"
                              Bed of gff format
    -c,--cat      => (STRING) Concatenate the outputs from -p and -l, boot and no boot. Must provide core filename
                              Typically, -c linc.prots.cat
    -t,--text     => (BOOL)   To get examples of command lines to use in R to process the outputs
    -w,--where    => (STRING) if BEDtools are not in your path, provide path to BEDtools bin directory
    -v,--version  => (BOOL)   print the version
    -h,--help     => (BOOL)   print this usage
\n";

#-----------------------------------------------------------------------------
#------------------------------ LOAD AND CHECK -------------------------------
#-----------------------------------------------------------------------------

my ($prot,$linc,$shuffle,$gaps,$dogaps,$build,$dobuild,$catout,$rprint,$v,$help);
my $inters = 10;
my $more = 0;
my $nboot = 100;
my $incl = "na";
my $bedtools = "";
my $opt_success = GetOptions(
			 	  'prot=s'		=> \$prot,
			 	  'lnc=s'		=> \$linc,
			 	  'shuffle=s'   => \$shuffle,
			 	  'overlap=s'   => \$inters,
			 	  'nboot=s'     => \$nboot,
			 	  'range=s'     => \$build,
			 	  'build'       => \$dobuild,
			 	  'more=s'      => \$more,
			 	  'incl=s'		=> \$incl,
			 	  'excl=s'		=> \$gaps,
			 	  'dogaps'      => \$dogaps,
			 	  'cat=s'		=> \$catout,
			 	  'text'        => \$rprint,
			 	  'where=s'     => \$bedtools,
			 	  'version'     => \$v,
			 	  'help'		=> \$help,);

#Check options, if files exist, etc
die "\n --- $scriptname version $version\n\n" if $v;
die $usage if $help || ! $opt_success;
die $usage unless $prot && $gaps && $shuffle;
die "\n -p $prot is not a gff file?\n\n" unless (($prot =~ /\.gff$/) || ($prot =~ /\.gff3$/));
die "\n -p $prot does not exist?\n\n"  if (! -e $prot);
die "\n -l $linc is not a gff file?\n\n" unless (($linc =~ /\.gff$/) || ($linc =~ /\.gff3$/));
die "\n -l $linc does not exist?\n\n"  if (! -e $linc);
die "\n -s $shuffle is not in a proper format (not .out, .bed, .gff or .gff)?\n\n" unless (($shuffle =~ /\.out$/) || ($shuffle =~ /\.bed$/) || ($shuffle =~ /\.gff$/) || ($shuffle =~ /\.gff3$/));
die "\n -s $shuffle does not exist?\n\n"  if (! -e $shuffle);
die "\n -i $incl does not exist?\n\n"  if (($incl ne "na") && (! -e $incl));
die "\n -r $build does not exist?\n\n"  if (! -e $build);
die "\n -e $gaps does not exist?\n\n"  if (! -e $gaps);
die "\n -n $nboot but should be an integer\n\n" if ($nboot !~ /\d+/);
die "\n -i $inters but should be an integer\n\n" if ($inters !~ /\d+/);
die "\n -m $more but should be an integer\n\n" if ($more !~ /\d+/);
die "\n -w $bedtools does not exist?\n\n"  if (($bedtools ne "") && (! -e $bedtools));
($dogaps)?($dogaps = "y"):($dogaps = "n");
($dobuild)?($dobuild = "y"):($dobuild = "n");
$bedtools = $bedtools."/" if (($bedtools ne "") && (substr($bedtools,-1,1) ne "/")); #put the / at the end of path if not there
$more = 1 if ($more == 0); #1 rep if set to 0, same thing here


#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
#Prep steps
print STDERR "\n --- $scriptname v$version\n";
print STDERR " --- loading sequence IDs from the genome range file (generating it if needed)\n";
my ($okseq,$build_file) = load_build($build,$dobuild);
print STDERR " --- loading ranges to exclude in randomization from $gaps\n";
my $gap_file = load_gap($gaps,$dogaps);
print STDERR " --- checking file in -s, print in .bed if not a .bed or gff file\n";
my $toshuff_file = RMtobed($shuffle,$okseq);
print STDERR " --- Load gene IDs / transcript IDs for for:\n";
my $whichgene = ();
my $l_tr = ();
my $p_tr = ();
print STDERR "  -> $linc\n";
($l_tr,$whichgene) = read_gff($linc, $okseq, 0, $whichgene); #comment if GAL::Annotation is a problem
# ($l_tr,$whichgene) = load_gene_tr($linc,$okseq,$whichgene); #uncomment if GAL::Annotation is a problem
print STDERR "  -> $prot\n";
($p_tr,$whichgene) = read_gff($prot, $okseq, 1, $whichgene); #comment if GAL::Annotation is a problem
# ($p_tr,$whichgene) = load_gene_tr($prot,$okseq,$whichgene); #uncomment if GAL::Annotation is a problem

#Outputs
my $stats = $linc.".".$nboot."boot.stats.txt";
my ($outl,$outp,$outlb,$outpb,$temp_l,$temp_p,$temp_s) = ("$linc.no_boot","$prot.no_boot","$linc.boot","$prot.boot","$linc.temp","$prot.temp","$toshuff_file.temp");
cleanup_out($outl,$outp,$outlb,$outpb,$catout,$stats,$temp_l,$temp_p,$temp_s,$nboot);

#Join -p and -l files
my $intersectBed = $bedtools."intersectBed";
print STDERR " --- Intersect with command lines:\n";
print STDERR "      $intersectBed -a $toshuff_file -b $linc -wa -wb > $temp_l/no_boot.joined\n";
system "$intersectBed -a $toshuff_file -b $linc -wa -wb > $temp_l/no_boot.joined";
print STDERR "      $intersectBed -a $toshuff_file -b $prot -wa -wb > $temp_p/no_boot.joined\n";
system "$intersectBed -a $toshuff_file -b $prot -wa -wb > $temp_p/no_boot.joined";

#Process the joined files with -m X repeats
print STDERR " --- Check intersections of $linc and $prot with features in $toshuff_file (observed)\n";
print STDERR "     (if -m set, there will be several rounds of random transcript selection)\n";
my $no_boot = ();
my $no_boot_tot_exons = ();
for(my $j = 1; $j <= $more; $j++) {
	print STDERR "     - round $j\n" unless ($more == 1);	
	($no_boot,$no_boot_tot_exons) = check_for_featured_overlap("$temp_l/no_boot.joined",$l_tr,"no_boot.".$j,'transcript',$outl,$inters,$no_boot,$no_boot_tot_exons,$whichgene);
	($no_boot,$no_boot_tot_exons) = check_for_featured_overlap("$temp_p/no_boot.joined",$p_tr,"no_boot.".$j,'mRNA',$outp,$inters,$no_boot,$no_boot_tot_exons,$whichgene);
	`cat $outl >> $catout.no-boot.txt` if (($catout) && (-e $outl));
	`cat $outp >> $catout.no-boot.txt` if (($catout) && (-e $outp));
}

#Now bootstrap runs
print STDERR " --- Run $nboot bootstraps now (to get significance of the overlaps)\n";
my $boots = ();
my $boots_tot_exons = ();
if ($nboot > 0) {
	foreach (my $i = 1; $i <= $nboot; $i++) {
		print STDERR "  -- BOOTSTRAP $i\n";	
		print STDERR "     Shuffle features with command line:\n";
		my $shuffled = shuffle($toshuff_file,$temp_s,$i,$gap_file,$incl,$build_file,$bedtools);
		print STDERR " --- Intersect with command lines:\n";
		print STDERR "      $intersectBed -a $shuffled -b $linc -wa -wb > $temp_l/boot.$i.joined\n";
		system "      $intersectBed -a $shuffled -b $linc -wa -wb > $temp_l/boot.$i.joined";
		print STDERR "      $intersectBed -a $shuffled -b $prot -wa -wb > $temp_p/boot.$i.joined\n";
		system "      $intersectBed -a $shuffled -b $prot -wa -wb > $temp_p/boot.$i.joined";
		print STDERR " --- Check intersections of $linc and $prot with features in $shuffled (expected)\n";
		($boots,$boots_tot_exons) = check_for_featured_overlap("$temp_l/boot.$i.joined",$l_tr,"boot.".$i,'transcript',$outlb,$inters,$boots,$boots_tot_exons,$whichgene);
		($boots,$boots_tot_exons) = check_for_featured_overlap("$temp_p/boot.$i.joined",$p_tr,"boot.".$i,'mRNA',$outpb,$inters,$boots,$boots_tot_exons,$whichgene);
		`cat $outlb >> $catout.boot.txt` if (($catout) && (-e $outlb));
		`cat $outpb >> $catout.boot.txt` if (($catout) && (-e $outpb));
		`rm -Rf $temp_l/boot.$i.joined $temp_p/boot.$i.joined $shuffled`; #these files are now not needed anymore, all is stored
	}
}
`rm -Rf $temp_l $temp_p $temp_s`; #these folders are not needed anymore

#Stats now
print STDERR " --- Get and print stats\n" if ($nboot > 0);
print_stats($stats,$no_boot,$more,$no_boot_tot_exons,$boots,$nboot,$boots_tot_exons,$scriptname,$version) if ($nboot > 0);

#R command lines if relevant
print STDERR " --- Print some R command lines\n" if ($rprint);
my $cmdlines = $linc;
($cmdlines =~ /\//)?($cmdlines =~ s/(.*)\/.*$/$1\/TEanalysis_Shuffle.R.example.txt/):($cmdlines = "TEanalysis_Shuffle.R.example.txt");
print_Rcmdlines($cmdlines,$scriptname,$version) if ($rprint);

#end
print STDERR " --- $scriptname done\n";
print STDERR "     Stats printed in: $stats\n" if ($nboot > 0);
print STDERR "     R command lines in $cmdlines\n" if ($rprint);
print STDERR "\n";
exit;


#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Get build if needed and get chromosomes included in it
# my ($okseq,$build_file) = load_build($build,$dobuild);
#-----------------------------------------------------------------------------
sub load_build{
    my ($file,$dobuild) = @_;
    my %build = ();
    my $build_file;
    if ($dobuild eq "n") {
    	$build_file = $file;
		open (my $in, '<', $file) or confess "ERROR (sub load_build): can't open to read $file $!\n";
		GAP_LINE: while(<$in>){
			chomp;
			my @l = split /\t/, $_;
			$build{$l[0]} = $l[1]; 
		}
		close $in;
    } else {
		print STDERR "     printing chrom. range file for $file\n";
    	$build_file = $file.".build.tab";
    	open (my $lenfh, ">", $build_file) or confess "ERROR (sub load_build): can't open to write $build_file $!\n";
		my $fa = Bio::SeqIO->new(-file => $file, -format => "fasta") or confess "ERROR (sub parse_build): can not open as fasta object $file $!\n";
		my %replen = ();
		while( my $seq = $fa->next_seq() ) {
			my $name = $seq->display_id;
			my $len = $seq->length;
			$build{$name} = $len;
			print $lenfh "$name\t$len\n";
		}
		undef $fa;
		close $lenfh;    
    }
    return (\%build,$build_file);
}

#-----------------------------------------------------------------------------
# loading assembly gaps
# my $gap_file = load_gap($gaps,$dogaps);
#-----------------------------------------------------------------------------
sub load_gap {
    my ($file,$dogaps) = @_;
    my $bed;  
	if ($dogaps eq "y") { 
	    #gaps not in file yet, get them from fasta file in bed format
		$bed = print_gap_bed($file);
	} else {
		print STDERR "     printing bed file for $file (limiting to features > 10nt)\n";
		#file with gaps, check if bed already
		($file =~ /\.bed$/)?($bed = $file):($bed = $file.".bed");
		if ($file !~ /\.bed$/) {
			open (my $in, '<', $file) or confess "ERROR (sub gap_file): can't open to read $file $!\n";
			open (my $out, '>', $bed) or confess "ERROR (sub gap_file): can't open to write $bed $!\n";
			LINE: while(<$in>){
				chomp(my $l = $_);
				next LINE if (substr($l,0,1) eq "#");
				my @l = split(/\t/,$l);			
				#bin, chrom, chromStart, chromEnd, ix, n, size, type, bridge)
				print $out "$l[1]\t$l[2]\t$l[3]\n" unless ($l[3]-$l[2] < 10);
			}
		close $in;
		close $out;
		}
	}
    return ($bed);
}

#-----------------------------------------------------------------------------
# printing assembly gaps if needed, in bed format
# $file = print_gap($file) if ($ifbuild eq "n");
#-----------------------------------------------------------------------------
sub print_gap_bed {
	my $file = shift;
	my $fasta = Bio::SeqIO->new(-file => $file, -format => "fasta") or confess "ERROR (sub print_gap_bed): failed to create SeqIO object from $file $!\n";
	my $gaps = "$file.gaps.bed";
	open my $gapfh, ">", $gaps or confess "ERROR (sub print_gap): could not open to write $gaps $!\n";
	while( my $seqfa = $fasta->next_seq() ) {
		my $head = $seqfa->display_id;
		my $seq = $seqfa->seq;
		$seq = uc($seq); #uppercases just in case
		my @seq = split("",$seq);
		my $Nstart = 0;
		my $Nlen = 0;
		NUCL: for (my $i = 0; $i <= $#seq; $i++){
			#go to next nt if this is not a gap to extend or first nt after a gap
			my $nt = $seq[$i];
			next NUCL if (($nt ne "N") && ($Nlen == 0));
			if ($nt eq "N") {
				$Nstart = $i+1 if ($Nlen == 0); #do not increment if extending gap
				$Nlen++; #will be 1 if was 0
			} else { #end of a gap, print and reintialize (already skipped if length is < 10)
				my $Nend = $Nlen + $Nstart - 1;
				print $gapfh "$head\t$Nstart\t$Nend\n" unless ($Nlen < 10);
				$Nstart = 0;
				$Nlen = 0;
			}
		}
	}
	undef $fasta;
	close $gapfh;
	return ($gaps);
}

#-----------------------------------------------------------------------------
# Convert RMoutput .out file to bed if needed
# my $toshuff_file = RMtobed($shuffle,$okseq);
#-----------------------------------------------------------------------------
sub RMtobed {
	my ($file,$okseq) = @_;
	return $file if ($file !~ /\.out$/); #other extensions already checked
	#now it means RM.out => make it a bed file
	my $ok = "$1.bed" if $file =~ /(.*)\.out$/;	
	open(my $fh, "<$file") or confess "\n   ERROR (sub RMtobed): could not open to read $file!\n";
	open(my $bed_fh, ">$ok") or confess "\n   ERROR (sub RMtobed): could not open to write $ok!\n";
	LINE: while(<$fh>) {
		chomp(my $l = $_);
		$l =~ s/^\s+//;
		next LINE if (($l =~ /^[Ss]core|^SW|^#/) || ($l !~ /\w/));
		$l = $1 if ($l =~ /^(.*)\*$/); #remove the star
		my @l = split('\s+',$l);
		next LINE unless (defined $okseq->{$l[4]}); #if not in build of stuff OK to shuffle on, remove here as well
		$l[8] =~ s/C/-/; #correct strand to match convention 
		
		#create unique ID = the RMout line
		my ($chr,$start,$end,$strand) = ($l[4],$l[5],$l[6],$l[8]);
		my $ID = $l[0];
		for (my $i=1; $i<=$#l;$i++) {
			$ID = $ID.";".$l[$i];
		}
		$ID =~ s/\s//; #should not need this, but just in case
		
# 		#correct the start if base is 0
# 		$start=$start+1 if ($base == 0);
		
		#now print in bed format
		print $bed_fh "$chr\t$start\t$end\t$ID\t.\t$strand\n"; #with ID being the whole line => easy to acces to RMoutput original info
	}
	close ($fh);
	close ($bed_fh);
	return ($ok);
}

#-----------------------------------------------------------------------------
# Load geneIDs{type}{trIDs}
# my $l_tr = load_gene_tr($lincs,$okseq,$whichgene);
# my $p_tr = load_gene_tr($prot,$okseq,$whichgene);
#-----------------------------------------------------------------------------
sub load_gene_tr {
	#Not as solid as using GAL::Annotation, but it is an alternative
	my ($file,$okseq,$whichgene) = @_;
	my %tr = ();
	my ($gid,$trid,$type);
	open(my $fh, "<$file") or confess "\n   ERROR (sub load_gene_tr): could not open to read $file!\n";
	LINE: while(<$fh>) {
		chomp(my $l = $_);
		next LINE if (substr($l,0,1) eq "#");
		my @l = split('\s+',$l);
		next LINE unless (defined $okseq->{$l[0]}); #if not in build of stuff OK to shuffle on, remove here as well
		my $id = $l[8];
		$id = $1 if $id =~ /^ID=(.+?);/;
		if ($l[2] eq "gene") {
			$gid = $id;
		} elsif ($l[2] eq "transcript") {
			$trid = $id;
			$type = "transcript";
			$type = "mRNA" if ($l =~ /protein_coding/); #if coding, it should be in the "gene_type" or the "transcript_type"
			$tr{$gid}{$type}{$trid}{'st'} = $l[3];
			$tr{$gid}{$type}{$trid}{'en'} = $l[4];
			$whichgene->{$trid}=$gid;
		} else {	
			$tr{$gid}{$type}{$trid}{'nb'}++ if ($l[2] eq "exon"); #count exons; includes UTRs for pc genes
# 			$tr{$gid}{$type}{$trid}{'nb'}++ if (($type eq "mRNA") && ($l[2] eq "CDS")); #count number of coding exons only
#			$tr{$gid}{$type}{$trid}{'nb'}++ if (($type eq "transcript") && ($l[2] eq "exon")); #count number of exons
		}
	}
	close ($fh);
	return (\%tr,$whichgene); #looping through keys will get transcripts => put in an array for each gene later
}

#-----------------------------------------------------------------------------
# Load geneIDs{type}{trIDs} with GAL::Annotation
# ($l_tr,$whichgene) = read_gff($linc, $okseq, 0, $whichgene);
# ($p_tr,$whichgene) = read_gff($linc, $okseq, 0, $whichgene);
#-----------------------------------------------------------------------------
sub read_gff {
	my ($gff3_file,$okseq,$coding,$whichgene) = @_;
    my %trinfo;
	my $gene_count=0;
	#load annotations through GAL::Annotation
    my $annotation = GAL::Annotation->new($gff3_file);
    my $features = $annotation->features;
    my $genes = $features->search({type => 'gene'});
    print STDERR "     GAL::Annotation has finished loading, now going through it\n";
	my $type = "transcript";
	GENE: while (my $gene = $genes->next) {
		if($coding eq 1){
			next GENE unless $gene->is_coding; #function updated Jan 2016 by Barry Moore to return true if any child is mRNA or has CDS exons
		}
		my $gene_id = $gene->feature_id;
		my $seqid   = $gene->seqid;
		next GENE unless (defined $okseq->{$seqid});
		
		my @tr = $gene->transcripts;
		TRANSCRIPT: foreach my $tr (@tr) {
			my $tr_id = $tr->feature_id;
			my $tr_strand = $tr->strand;
			if($tr_strand !~ /\+|-/){
				print STDERR "     Warning: transcript strand for $tr_id is undetermined ($tr_strand)\n";
				next TRANSCRIPT;
			}
			
			#Check if transcript is coding or not
			$type = "mRNA" if ($tr->has_CDS);
			my @exons = sort { $a->start <=> $b->start } $tr->exons;
# 			if ($type eq 'mRNA') {
# 				@exons = sort { $a->start <=> $b->start } $transcript->CDSs;
# 			} else {
# 				@exons = sort { $a->start <=> $b->start } $transcript->exons;
# 			}
			#Now get info of number of exons in this transcript
			$trinfo{$gene_id}{$type}{$tr_id}{'st'}=$tr->start;
			$trinfo{$gene_id}{$type}{$tr_id}{'en'}=$tr->end;
			$trinfo{$gene_id}{$type}{$tr_id}{'nb'}=scalar(@exons);
			$whichgene->{$tr_id}=$gene_id;
		}
		$gene_count++;		
	}
    print STDERR "        total genes loaded (type=$type): $gene_count\n";	
	return (\%trinfo,$whichgene);
}

#-----------------------------------------------------------------------------
# Cleanup outputs
# cleanup_out($outl,$outp,$outlb,$outpb,$catout,$stats,$temp_l,$temp_p,$temp_s,$nboot);
#-----------------------------------------------------------------------------
sub cleanup_out {
	my ($outl,$outp,$outlb,$outpb,$catout,$stats,$temp_l,$temp_p,$temp_s,$nboot) = @_;
	`mv $outl $outl.previous` if (-e $outl);
	`mv $outp $outp.previous` if (-e $outp);
	`mv $outlb $outlb.previous` if (-e $outlb);
	`mv $outpb $outpb.previous` if (-e $outpb);
	`mv $catout.no-boot.txt $catout.no-boot.txt.previous` if (($catout) && (-e "$catout.no-boot.txt"));
	`mv $catout.boot.txt $catout.boot.txt.previous` if (($catout) && (-e "$catout.boot.txt"));
	`mv $stats $stats.previous` if (-e $stats);
	`rm -Rf $temp_l` if (-e $temp_l);
	`rm -Rf $temp_p` if (-e $temp_p);
	`rm -Rf $temp_s` if (-e $temp_s);
	`mkdir $temp_l`;
	`mkdir $temp_p`;
	`mkdir $temp_s` if ($nboot > 0);
	return 1;
}	

#-----------------------------------------------------------------------------
# Shuffle, with bedtools
# my $shuffled = shuffle($toshuff_file,$temp_s,$i,$gap_file,$incl,$build_file,$bedtools);
#-----------------------------------------------------------------------------
sub shuffle {
	my ($toshuff_file,$temp_s,$nb,$gap_file,$incl,$build,$bedtools) = @_;
	my $out = $temp_s."/shufffled".$nb;
	my $bed_shuffle = $bedtools."bedtools shuffle";
	($incl eq "na")?(print STDERR "      $bed_shuffle -i $toshuff_file -excl $gap_file -f 10 -noOverlapping -g $build -chrom -maxTries 10000 > $out\n"):
	                (print STDERR "      $bed_shuffle -incl $incl -i $toshuff_file -excl $gap_file -f 10 -noOverlapping -g $build -chrom -maxTries 10000 > $out\n");
	($incl eq "na")?(system "$bed_shuffle -i $toshuff_file -excl $gap_file -f 10 -noOverlapping -g $build -chrom -maxTries 10000 > $out"):
	                (system "$bed_shuffle -incl $incl -i $toshuff_file -excl $gap_file -f 10 -noOverlapping -g $build -chrom -maxTries 10000 > $out");	
	return ($out);

}

#-----------------------------------------------------------------------------
# Check overlap with TEs and count
# Keep only one transcript per gene -> requires to load transcript IDs per gene
#  	($no_boot,$no_boot_tot_exons) = check_for_featured_overlap($linc,$l_tr,"no_boot.".$j,'transcript',$outl,$inters,$no_boot,$no_boot_tot_exons,$whichgene);
#	($no_boot,$no_boot_tot_exons) = check_for_featured_overlap($prot,$p_tr,"no_boot.".$j,'mRNA',$outp,$inters,$no_boot,$no_boot_tot_exons,$whichgene);
# 	($boots,$boots_tot_exons) = check_for_featured_overlap($linc,$l_tr,"boot.".$i,'transcript',$outlb,$inters,$boots,$boots_tot_exons,$whichgene);
# 	($boots,$boots_tot_exons) = check_for_featured_overlap($prot,$p_tr,"boot.".$i,'mRNA',$outpb,$inters,$boots,$boots_tot_exons,$whichgene);
#-----------------------------------------------------------------------------
sub check_for_featured_overlap {
	my ($file, $infos, $fileid, $type, $out, $inters, $counts, $total_exons, $whichgene) = @_;
	my %chosen_tr = ();
	my %checkgenes = ();
	my %checkexons = ();
	
	#initialize exon count for this run
	$total_exons->{$type}{$fileid}{'tot'}=0;
	$total_exons->{$type}{$fileid}{'hit'}=0;
	
	#initialize counting of categories if needed
	unless (defined $counts->{'TSS'}{$type}{$fileid}) {
		$counts->{'TSS_polyA'}{$type}{$fileid}=0;
		$counts->{'TSS_5SPL'}{$type}{$fileid}=0;
		$counts->{'TSS'}{$type}{$fileid}=0;
		$counts->{'5SPL'}{$type}{$fileid}=0;
		$counts->{'3SPL'}{$type}{$fileid}=0;
		$counts->{'3SPL_exon_5SPL'}{$type}{$fileid}=0;
		$counts->{'exonized'}{$type}{$fileid}=0;
		$counts->{'3SPL_polyA'}{$type}{$fileid}=0;
		$counts->{'polyA'}{$type}{$fileid}=0;
	}
	
	#now loop
	open(my $fh, "<$file") or confess "\n   ERROR (sub check_for_featured_overlap): could not open to read $file!\n";
	LINE: while(<$fh>){
		chomp(my $l = $_);
		next LINE if (substr($l,0,1) eq "#");
		my @l = split(/\s+/,$l);
# 		if ($l[8] eq "transcript") {
# 			#TO DO: count intron hits when transcript hit but not exon hit, using a flag; for now it does not matter
# 		} elsif {
		if ($l[8] eq "exon") {
			my $trid = $l[14];
			$trid = $1 if $trid =~ /Parent=(.+?);/;
			next LINE unless (defined $whichgene->{$trid}); #checked for non coding when coding are looked at

			#get a random tr for this gene, but only the first time this gene is met, and keep which tr is chosen			
			my $gid = $whichgene->{$trid};			
			$chosen_tr{$gid} = random_tr($infos,$gid,$type) unless (defined $chosen_tr{$gid}); #%infos contain infos about the transcript => start, end, number of exons in it
			my $chosen = $chosen_tr{$gid};
			$total_exons->{$type}{$fileid}{'tot'}+=$infos->{$gid}{$type}{$chosen}{'nb'} unless (defined $checkgenes{$gid}); #increment with exon numbers of the transcript chosen for this gene
			$checkgenes{$gid}=1; #store that exons of a random transcript for this gene have been counted			
			next LINE if ($trid ne $chosen_tr{$gid}); #skip if not randomly chosen transcript that is hit	
			#OK now check what category of overlap this exon is;
			my ($cat,$ilen) = overlap_category(\@l,$infos,$gid,$type,$trid);
			next LINE unless ($ilen >= $inters);
			#since only one transcript per gene, there should be no worry here about unique counts, 1 exon can only be counted one time in a category; 
			#however unique exon hits count need a check, and there could be TE overlaps fucking things up, so better safe than sorry
			$counts->{$cat}{$type}{$fileid}++ unless (defined $checkexons{$l[14]}{$cat});
			$total_exons->{$type}{$fileid}{'hit'}++ unless (defined $checkexons{$l[14]}{'hit'});
			$checkexons{$l[14]}{$cat}=1;
			$checkexons{$l[14]}{'hit'}=1;
		}
	}
	close ($fh);
		
	#Add to total exons the number of exons in a random transcript of each gene that was not already counted		
	GENE: foreach my $gene (keys %{$infos}) {
		next GENE if (defined $checkgenes{$gene});
		my $chosen = random_tr($infos,$gene,$type);
		$total_exons->{$type}{$fileid}{'tot'}+=$infos->{$gene}{$type}{$chosen}{'nb'};
	}
		
	#Now print stuff
	print_out($counts,$total_exons,$fileid,$type,$out);
	
	return ($counts,$total_exons);
}

#FYI:
# chr1	4522383	4522590	1111;18.9;4.6;1.0;chr1;4522383;4522590;(190949381);-;B3;SINE/B2;(0);216;1;1923	.	-	chr1	Cufflinks	gene	4496315	4529218	.	+	.	ID=XLOC_000001;Name=uc007aez.1;
# chr1	4522383	4522590	1111;18.9;4.6;1.0;chr1;4522383;4522590;(190949381);-;B3;SINE/B2;(0);216;1;1923	.	-	chr1	Cufflinks	transcript	4496316	4523815	.	+	.	ID=TCONS_00000002;Parent=XLOC_000001;
# chr1	4522383	4522590	1111;18.9;4.6;1.0;chr1;4522383;4522590;(190949381);-;B3;SINE/B2;(0);216;1;1923	.	-	chr1	Cufflinks	transcript	4496315	4528991	.	+	.	ID=TCONS_00000001;Parent=XLOC_000001;
# chr1	4523602	4524133	4334;3.7;0.0;2.6;chr1;4523602;4524133;(190947838);-;L1MdF_IV;LINE/L1;(2);6577;6060;1924	.	-	chr1	Cufflinks	exon	4522788	4523815	.	+	.	ID=exon:TCONS_00000002:2;Parent=TCONS_00000002;
# chr1	4523602	4524133	4334;3.7;0.0;2.6;chr1;4523602;4524133;(190947838);-;L1MdF_IV;LINE/L1;(2);6577;6060;1924	.	-	chr1	Cufflinks	transcript	4524076	4529218	.	+	.	ID=TCONS_00000003;Parent=XLOC_000001;
# chr1	4523602	4524133	4334;3.7;0.0;2.6;chr1;4523602;4524133;(190947838);-;L1MdF_IV;LINE/L1;(2);6577;6060;1924	.	-	chr1	Cufflinks	exon	4524076	4529218	.	+	.	ID=exon:TCONS_00000003:1;Parent=TCONS_00000003;
# chr1	4523602	4524133	4334;3.7;0.0;2.6;chr1;4523602;4524133;(190947838);-;L1MdF_IV;LINE/L1;(2);6577;6060;1924	.	-	chr1	Cufflinks	gene	4496315	4529218	.	+	.	ID=XLOC_000001;Name=uc007aez.1;
# chr1	4523602	4524133	4334;3.7;0.0;2.6;chr1;4523602;4524133;(190947838);-;L1MdF_IV;LINE/L1;(2);6577;6060;1924	.	-	chr1	Cufflinks	transcript	4496316	4523815	.	+	.	ID=TCONS_00000002;Parent=XLOC_000001;
# chr1	4523602	4524133	4334;3.7;0.0;2.6;chr1;4523602;4524133;(190947838);-;L1MdF_IV;LINE/L1;(2);6577;6060;1924	.	-	chr1	Cufflinks	transcript	4496315	4528991	.	+	.	ID=TCONS_00000001;Parent=XLOC_000001;
# chr1	4524134	4524434	2591;2.7;0.3;0.0;chr1;4524134;4524434;(190947537);+;L1MdF_V;LINE/L1;4716;5017;(1562);1925	.	+	chr1	Cufflinks	transcript	4524076	4529218	.	+	.	ID=TCONS_00000003;Parent=XLOC_000001;
# chr1	4524134	4524434	2591;2.7;0.3;0.0;chr1;4524134;4524434;(190947537);+;L1MdF_V;LINE/L1;4716;5017;(1562);1925	.	+	chr1	Cufflinks	exon	4524076	4529218	.	+	.	ID=exon:TCONS_00000003:1;Parent=TCONS_00000003;

#-----------------------------------------------------------------------------
# Get random transcript
# $chosen_tr = random_tr($infos,$gene_id,$type);
#-----------------------------------------------------------------------------
sub random_tr {
	my ($infos,$gene_id,$type) = @_;
	my @trid = keys (%{$infos->{$gene_id}{$type}});
	my $r = int(rand(scalar(@trid)));
	return ($trid[$r]);
}

#-----------------------------------------------------------------------------
# Get the overlap category
# my ($cat,$ilen) = overlap_category($l,$infos,$gid,$type,$trid);
#-----------------------------------------------------------------------------
sub overlap_category {
	my ($l,$infos,$gid,$type,$trid) = @_;
	my ($Trstart,$Trend,$Trex) = ($infos->{$gid}{$type}{$trid}{'st'},$infos->{$gid}{$type}{$trid}{'en'},$infos->{$gid}{$type}{$trid}{'nb'});
	my ($Gstart,$Gend,$st,$en,$strand) = ($l->[1],$l->[2],$l->[9],$l->[10],$l->[12]);	
	my $cat = "exonized"; #the default
	my $ilen = ($Gend-$Gstart+1); #if exonized

	#Check the TSS_polyA with Tr corrdinates first, indep of strand. Could also be below with overhang both sides, but cleaner to double check with transcript coordinates
	$cat = "TSS_polyA" if (($Gstart<$Trstart) && ($Gend>$Trend));
	
	#Now the rest; easiest is to set what are the exons
	my $ExType = "MIDDLE";
	$ExType = "FIRST" if ((($strand eq "+") && ($st == $Trstart)) || (($strand eq "-") && ($en == $Trend)));
	$ExType = "LAST" if ((($strand eq "+") && ($en == $Trend)) || (($strand eq "-") && ($st == $Trstart)));
	
	if ($Gstart < $st) {
		if ($Gend > $en) { # overhang TE start AND end side
			$ilen = $en-$st+1;
			$cat = "3SPL_exon_5SPL";
			$cat = "TSS_5SPL" if ($ExType eq "FIRST");
			$cat = "3SPL_polyA" if ($ExType eq "LAST");
		} else {  #overhang TE start side only
			$ilen = $Gend-$st+1;
			($strand eq "+")?($cat = "3SPL"):($cat = "5SPL");
			$cat = "polyA" if (($strand eq "-") && (($Trex == 1) || ($ExType eq "LAST")));
			$cat = "TSS" if (($strand eq "+") && (($Trex == 1) || ($ExType eq "FIRST")));
		}
	} elsif ($Gend > $en) { # => overhang only end side
		$ilen = $en-$Gstart+1;
		($strand eq "+")?($cat = "5SPL"):($cat = "3SPL");
		$cat = "TSS" if (($strand eq "-") && (($Trex == 1) || ($ExType eq "FIRST")));
		$cat = "polyA" if (($strand eq "+") && (($Trex == 1) || ($ExType eq "LAST")));
	}
	return ($cat,$ilen);
}

#-----------------------------------------------------------------------------
# Print out details of boot and no_boot stuff
# print_out($counts,$total_exons,$fileid,$type,$out);
#-----------------------------------------------------------------------------
sub print_out {
	my ($counts,$total_exons,$fileid,$type,$out) = @_;
	open (my $fh, ">>", $out) or confess "ERROR (sub print_out): can't open to write $out $!\n";
	foreach my $cat (keys %{$counts}) {
		my $tot = $total_exons->{$type}{$fileid}{'tot'};
		my $hit = $total_exons->{$type}{$fileid}{'hit'};
		my $unhit = $tot-$hit;
		print $fh "$type\t$fileid\t$cat\t$counts->{$cat}{$type}{$fileid}\t$hit\t$tot\t$unhit\n"; #this will be a bit disorganized, whatever
	}
	close $fh;
    return 1;
}

#-----------------------------------------------------------------------------
# Print Stats (permutation test basically) + associated subroutines
# print_stats($stats,$no_boot,$more,$no_boot_tot_exons,$boots,$nboot,$boots_tot_exons,$scriptname,$version) if ($nboot > 0);
#-----------------------------------------------------------------------------
sub print_stats {
	my ($out,$no_boot,$more,$no_boot_tot_ex,$boots,$nboot,$boot_tot_ex,$scriptname,$version) = @_;
	
	#get the boot and no_boot total_exons values, avg and sd
	my $no_boot_exons = get_exon_data($no_boot_tot_ex);
	my $boot_exons = get_exon_data($boot_tot_ex);

	#get the no_boot values, avg and sd
	my $obs = get_cat_data($no_boot,0,"na");
	my $exp = get_cat_data($boots,$nboot,$obs);
	
	#now print
	open (my $fh, ">", $out) or confess "ERROR (sub print_stats): can't open to write $out $!\n";	
	print $fh "#Script $scriptname, v$version\n";
	print $fh "#Aggregated results + stats\n";
	print $fh "#With $more repetitions for obs (observed) and $nboot bootstraps for exp (expected)\n";
	print $fh "#The p value shows how significant the difference between observed and random is (permutation test)\n";
	print $fh "#Note that for now, total amount of hit exons is not taken in account\n";
	print $fh "\n#trancript_type\toverlap_category\tobs_mean_exons\tobs_mean_exons_sd\tobs_tot_exons\tobs_tot_exons_sd\texp_mean_exons\texp_mean_exons_sd\tobs_rank_in_exp\tobs_vs_exp_pvalue\n\n";
	
	foreach my $cat (keys %{$obs}) {
		foreach my $type (keys %{$obs->{$cat}}) {
			my $pval = $exp->{$cat}{$type}{'pval'};
			$pval = "na" if (($exp->{$cat}{$type}{'avg'} == 0) && ($obs->{$cat}{$type}{'avg'} == 0)); #should not happen with enough bootstraps
			print $fh "$type\t$cat\t$obs->{$cat}{$type}{'avg'}\t$obs->{$cat}{$type}{'sd'}\t$no_boot_exons->{$type}{'avg'}\t$no_boot_exons->{$type}{'sd'}\t$exp->{$cat}{$type}{'avg'}\t$exp->{$cat}{$type}{'sd'}\t$exp->{$cat}{$type}{'rank'}\t$pval\n";		
		}
	}
	close $fh;
    return 1;
}
sub get_exon_data {
	my $tot_ex = shift;
	my %exons = ();
	foreach my $type (keys %{$tot_ex}) {
		my @data = ();
		foreach my $round (keys %{$tot_ex->{$type}}) {
			push(@data,$tot_ex->{$type}{$round}{'tot'});	
		}
		#get average and standard deviation from @data
		($exons{$type}{'avg'},$exons{$type}{'sd'}) = get_avg_and_sd(\@data);
	}
	return(\%exons);
}
sub get_cat_data {
	my ($all_data,$n,$obs) = @_;
	my %cat_data = ();
	foreach my $cat (keys %{$all_data}) {
		foreach my $type (keys %{$all_data->{$cat}}) {
			my @data = ();
			foreach my $round (keys %{$all_data->{$cat}{$type}}) {
				push(@data,$all_data->{$cat}{$type}{$round});	
			}
			#get average and standard deviation from @data
			($cat_data{$cat}{$type}{'avg'},$cat_data{$cat}{$type}{'sd'}) = get_avg_and_sd(\@data);
			#Now get he rank of the observed value in the list of expected => get a p value
			unless ($n == 0) {
				my $rank = 1; #base 1, not 0...
				@data = sort {$a <=> $b} @data;
				EXP: foreach my $exp (@data) {
					$rank++ if ($exp < $obs->{$cat}{$type}{'avg'});
					last EXP if ($exp > $obs->{$cat}{$type}{'avg'});
				}
				$cat_data{$cat}{$type}{'rank'}=$rank;
				$cat_data{$cat}{$type}{'pval'}=$rank/$nboot;
			}
		}
	}
	return(\%cat_data);
}
sub get_avg_and_sd{
	my($data) = @_;
    confess "ERROR (sub print_stats/get_avg_and_sd): empty data array $!\n" if (not @$data);
    return (0,0) if (@$data == 1);
        
	my $total = 0;
	foreach (@$data) {
		$total += $_;
	}
	my $avg = $total / @$data;

	my $sqtotal = 0;
	foreach(@$data) {
		$sqtotal += ($avg-$_) ** 2;
	}
	my $sd = ($sqtotal / (@$data-1)) ** 0.5;
	return ($avg,$sd);
}

#-----------------------------------------------------------------------------
# Print R command lines (examples)
# print_Rcmdlines($cmdlines,$scriptname,$version) if ($rprint);
#-----------------------------------------------------------------------------
sub print_Rcmdlines {
    my ($file,$scriptname,$version) = @_;
	
	open (my $fh, ">", $file) or confess "ERROR (sub print_Rcmdlines): can't open to write $file $!\n";
	print $fh "#Example of R command lines to process the output files
#From the script $scriptname, v$version
#Prior to running these, concatenate the outputs of -l and -p if -c not used
#Run these command lines for both the boot and no_boot files (X=boot or X=no_boot in the read.csv below)

setwd(\"/Users/my/Documents/ProjectName\")
library(ggplot2)
dat<-read.csv(\"file.cat.X\", sep=\"\\t\", header=FALSE)
#dat
new.dat<-aggregate(dat\$V4, by=list(dat\$V1,dat\$V3),mean)
new.dat\$sd<-aggregate(dat\$V4, by=list(dat\$V1,dat\$V3),sd)\$x
new.dat\$mean_exon<-aggregate(dat\$V5, by=list(dat\$V1,dat\$V3),mean)\$x
new.dat\$total<-aggregate(dat\$V6, by=list(dat\$V1,dat\$V3),mean)\$x
new.dat\$unhit<-aggregate(dat\$V7, by=list(dat\$V1,dat\$V3),mean)\$x
#new.dat
dat2<-dat[grep(dat\$V3, pattern=\"TSS_PolyA\", invert=TRUE),]
ggplot(dat2, aes(x=V3, y=V4))+geom_boxplot()+facet_grid(.~V1)
new.dat";

	close $fh;
    return 1;
}



